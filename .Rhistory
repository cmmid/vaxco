library(data.table)
library(ggplot2)
library(lubridate)
library(here)
library(cowplot)
library(readxl)
library(socialmixr)
library(qs)
library(zoo)
#
# SETUP
#
# set up covidm
cm_path = "~/Dropbox/nCoV/covidm/";
cm_force_rebuild = F;
cm_build_verbose = T;
cm_version = 2;
source(paste0(cm_path, "/R/covidm.R"))
#
# ADD LMIC REGIONS
#
worldpop = fread("./worldpop5yr.lfs.csv")
add_region = function(pid)
{
dat = worldpop[id == pid];
f = dat[, unlist(unname(.SD)), .SDcols = 10:26] / 1000;
m = dat[, unlist(unname(.SD)), .SDcols = 27:43] / 1000;
groups = limits_to_agegroups(seq(0, 80, by = 5));
new_rows = data.table(country_code = 8888, name = dat[, unique(name)][1], age = groups, f = f, m = m, location_type = 4);
cm_populations <<- rbind(cm_populations, new_rows)
}
add_region("ETH.1")
add_region("IND.25")
add_region("KEN.30")
add_region("PAK.8")
add_region("ZAF.3")
#
# RUNS
#
# load epi data
epi = fread("~/Dropbox/Covid_LMIC/nCoV-LMIC/epi_data.csv")
# load mobility data
mob = fread("~/Dropbox/Covid_LMIC/nCoV-LMIC/mob_data.csv")
# not needed for this, but might be useful to have
# source("process_def.R")
# Sindh
fitS = qread("fit_sindh.qs")
test = cm_backend_sample_fit_test(cm_translate_parameters(fitS$par), fitS$post, 50, seed = 0);
test = rbindlist(test)
ggplot(test[group == 2, .(d = obs0), by = .(run, t)]) +
geom_line(aes(x = t, y = d, colour = run, group = run)) +
geom_point(data = epi[location == "Sindh"], aes(x = as.numeric(ymd(date) - ymd("2020-01-01")), y = rollmean(deaths, 7, fill = NA))) +
theme(legend.position = "none") + labs(x = "Time (days)", y = "Deaths")
names(fitS)
cm_source_backend(user_defined = fitS$user_defined)
library(data.table)
library(ggplot2)
library(lubridate)
library(qs)
# set up covidm
cm_path = "~/Dropbox/nCoV/covidm/";
cm_force_rebuild = F;
cm_build_verbose = T;
cm_version = 2;
source(paste0(cm_path, "/R/covidm.R"))
# load epi data
epi = fread("~/Dropbox/Covid_LMIC/nCoV-LMIC/epi_data.csv")
# load mobility data
mob = fread("~/Dropbox/Covid_LMIC/nCoV-LMIC/mob_data.csv")
# Sindh
fitS = qread("fit_sindh.qs")
cm_source_backend(user_defined = fitS$user_defined)
test = cm_backend_sample_fit_test(cm_translate_parameters(fitS$par), fitS$post, 50, seed = 0);
test = rbindlist(test)
ggplot(test[group == 2, .(d = obs0), by = .(run, t)]) +
geom_line(aes(x = t, y = d, colour = run, group = run)) +
geom_point(data = epi[location == "Sindh"], aes(x = as.numeric(ymd(date) - ymd("2020-01-01")), y = rollmean(deaths, 7, fill = NA))) +
theme(legend.position = "none") + labs(x = "Time (days)", y = "Deaths")
ggplot(test[, .(d = sum(cases) * 0.025), by = .(run, t)]) +
geom_point(aes(x = t, y = d, colour = run)) +
geom_line(data = epi[location == "Sindh"], aes(x = as.numeric(ymd(date) - ymd("2020-01-01")), y = cases))
fitS$par
# set parameters
fitS$par$pop[[1]]$ev
fitS$par$pop[[1]]$wn
library(data.table)
library(ggplot2)
library(lubridate)
library(qs)
# Sampling parameters
p = list(
n_samples = 50,         # number of samples from posterior
rng_seed = 0,           # RNG seed; 0 means default for RNG
vax_eff = rep(0.8, 16), # probability of vaccine giving protection until waning (by age group)
dur_nat = rep(180, 16), # duration in dats of natural immunity (by age group)
dur_vax = rep(180, 16)  # duration in days of vaccine immunity (by age group)
)
# for Carl
# fitted up to September X
# waning of immunity
# reintroduction process
# deterministic version
# support prevent disease only?
# parameters to sweep
# - one versus two dose (don't worry about...)
# - vaccine efficacy
# - waning of vaccine efficacy
# - waning of natural immunity
# - different coverage
# - different age targeting
# demonstrating that the set of scenarios can be analysed for a setting.
# endpoints: cases, deaths, admissions
# a single task runs over the model posterior; params for sweeping one set per task.
#
#
# SETUP
#
# set up covidm
cm_path = "~/Dropbox/nCoV/covidm/";
cm_force_rebuild = F;
cm_build_verbose = T;
cm_version = 2;
source(paste0(cm_path, "/R/covidm.R"))
#
# RUNS
#
# load epi data
epi = fread("~/Dropbox/Covid_LMIC/nCoV-LMIC/epi_data.csv")
# load mobility data
mob = fread("~/Dropbox/Covid_LMIC/nCoV-LMIC/mob_data.csv")
# not needed for this, but might be useful to have
# source("process_def.R")
# Sindh
fitS = qread("fit_sindh.qs")
cm_source_backend(user_defined = fitS$user_defined)
# set parameters
fitS$par$pop[[1]]$ev = vax_eff
fitS$par$pop[[1]]$wn = 365 / dur_nat
fitS$par$pop[[1]]$wv = 365 / dur_vax
run = cm_backend_sample_fit_test(cm_translate_parameters(fitS$par), fitS$post, n_samples, seed = rng_seed);
run = rbindlist(run)
# set parameters
fitS$par$pop[[1]]$ev = p$vax_eff
fitS$par$pop[[1]]$wn = 365 / p$dur_nat
fitS$par$pop[[1]]$wv = 365 / p$dur_vax
run = cm_backend_sample_fit_test(cm_translate_parameters(fitS$par), fitS$post, p$n_samples, seed = p$rng_seed);
run = rbindlist(run)
ggplot(run[group == 2, .(d = obs0), by = .(run, t)]) +
geom_line(aes(x = t, y = d, colour = run, group = run)) +
geom_point(data = epi[location == "Sindh"], aes(x = as.numeric(ymd(date) - ymd("2020-01-01")), y = rollmean(deaths, 7, fill = NA))) +
theme(legend.position = "none") + labs(x = "Time (days)", y = "Deaths")
# Sampling parameters
p = list(
n_samples = 50,         # number of samples from posterior
rng_seed = 0,           # RNG seed; 0 means default for RNG
vax_eff = rep(0.8, 16), # probability of vaccine giving protection until waning (by age group)
dur_nat = rep(180000, 16), # duration in dats of natural immunity (by age group)
dur_vax = rep(180000, 16)  # duration in days of vaccine immunity (by age group)
)
# set up covidm
cm_path = "~/Dropbox/nCoV/covidm/";
cm_force_rebuild = F;
cm_build_verbose = T;
cm_version = 2;
source(paste0(cm_path, "/R/covidm.R"))
# load epi data
epi = fread("~/Dropbox/Covid_LMIC/nCoV-LMIC/epi_data.csv")
# load mobility data
mob = fread("~/Dropbox/Covid_LMIC/nCoV-LMIC/mob_data.csv")
# Sindh
fitS = qread("fit_sindh.qs")
cm_source_backend(user_defined = fitS$user_defined)
# set parameters
fitS$par$pop[[1]]$ev = p$vax_eff
fitS$par$pop[[1]]$wn = 365 / p$dur_nat
fitS$par$pop[[1]]$wv = 365 / p$dur_vax
run = cm_backend_sample_fit_test(cm_translate_parameters(fitS$par), fitS$post, p$n_samples, seed = p$rng_seed);
run = rbindlist(run)
ggplot(run[group == 2, .(d = obs0), by = .(run, t)]) +
geom_line(aes(x = t, y = d, colour = run, group = run)) +
geom_point(data = epi[location == "Sindh"], aes(x = as.numeric(ymd(date) - ymd("2020-01-01")), y = rollmean(deaths, 7, fill = NA))) +
theme(legend.position = "none") + labs(x = "Time (days)", y = "Deaths")
library(data.table)
library(ggplot2)
library(lubridate)
library(qs)
# Scenario parameters
# TODO what this does not cover yet: any vaccines being disbursed (how many doses to which age groups, when)
p = list(
n_samples = 50,         # number of samples from posterior
rng_seed = 0,           # RNG seed; 0 means default for RNG
vax_eff = rep(0.8, 16), # probability of vaccine giving protection until waning (by age group)
dur_nat = rep(180000, 16), # duration in dats of natural immunity (by age group)
dur_vax = rep(180000, 16)  # duration in days of vaccine immunity (by age group)
)
#
# SETUP
#
cm_path = "~/Dropbox/nCoV/covidm/";
cm_force_rebuild = F;
cm_build_verbose = T;
cm_version = 2;
source(paste0(cm_path, "/R/covidm.R"))
#
# RUNS
#
# load epi & mobility data
epi = fread("epi_data.csv")
mob = fread("mob_data.csv")
# load model fit for Singh and set up model
fitS = qread("fit_sindh.qs")
cm_source_backend(user_defined = fitS$user_defined)
# set parameters for this set of scenario runs
fitS$par$pop[[1]]$ev = p$vax_eff
fitS$par$pop[[1]]$wn = 365 / p$dur_nat
fitS$par$pop[[1]]$wv = 365 / p$dur_vax
fitS$par$time1 = 730
ggplot(run[, .(d = sum(cases) * 0.025), by = .(run, t)]) +
geom_point(aes(x = t, y = d, colour = run)) +
geom_line(data = epi[location == "Sindh"], aes(x = as.numeric(ymd(date) - ymd("2020-01-01")), y = cases))
ggplot(run[, .(d = sum(cases) * 0.05), by = .(run, t)]) +
geom_point(aes(x = t, y = d, colour = run)) +
geom_line(data = epi[location == "Sindh"], aes(x = as.numeric(ymd(date) - ymd("2020-01-01")), y = cases))
# note modelled cases do not fit well with reported cases, even with a constant underascertainment rate
ggplot(run[, .(d = sum(cases) * 0.1), by = .(run, t)]) +
geom_point(aes(x = t, y = d, colour = run)) +
geom_line(data = epi[location == "Sindh"], aes(x = as.numeric(ymd(date) - ymd("2020-01-01")), y = cases))
install.packages("RcppGSL")
install.packages("lubridate")
install.packages("lubridate")
install.packages("generics")
install.packages("lubridate")
install.packages("HDInterval")
install.packages("cowplot")
install.packages("RSQLite")
install.packages("DBI")
install.packages("RSQLite")
install.packages("bit64")
install.packages("RSQLite")
install.packages("blob")
install.packages("RSQLite")
install.packages("memoise")
install.packages("RSQLite")
suppressPackageStartupMessages({
require(data.table)
require(RSQLite)
require(ggplot2)
})
.args <- if (interactive()) c(
"results.sqlite", "overview.png"
) else commandArgs(trailingOnly = TRUE)
suppressPackageStartupMessages({
require(data.table)
require(qs)
require(RSQLite)
})
.args <- if (interactive()) c(
"fit_sindh.qs", "epi_data.csv", "mob_data.csv",
"results.sqlite", "5", "../covidm"
) else commandArgs(trailingOnly = TRUE)
# load fitted model for Sindh
fitS = qread(.args[1])
# load epi & mobility data
epi = fread(.args[2])
mob = fread(.args[3])
# TODO fish out scenario
scndb <- .args[4]
scnid <- as.integer(.args[5])
drv <- RSQLite::SQLite()
conn <- dbConnect(drv, scndb)
scen.dt <- as.list(data.table(dbReadTable(conn, "scenario"))[id == scnid])
scen.dt$n_samples <- dbGetQuery(conn, "SELECT max(particleId) FROM sample;")[,1]
#' TODO pull from pars table?
#' also, need to set selections from covidm sampling
scen.dt$rng_seed <- 0
dbDisconnect(conn)
scen.dt$n_samples
scen.dt$n_samples <- 5
cm_path <- tail(.args, 1)
# load covidm
cm_force_rebuild = F;
cm_build_verbose = F;
cm_force_shared = T;
cm_version = 2;
source(file.path(cm_path, "R", "covidm.R"))
date_vax <- as.Date(scen.dt$start_timing, origin = "1970-01-01")
t_vax <- as.numeric(date_vax - as.Date(fitS$par$date0))
#' first 3 years + vax anniversaries
validation_times <- 1:(365*3)
anni_times <- seq(t_vax+365, by=365, length.out = 10)
record_times <- unique(c(validation_times, anni_times))
mk_waning <- function(baseline_dur_days, ages = 16, age_dur_mods = rep(1, ages) ) {
rep(
ifelse(baseline_dur_days == 0, 0, 1/baseline_dur_days),
ages
) / age_dur_mods
}
fitS$par$time1 = t_vax + 10*365 # 10 years of anniversaries
fitS$par$pop[[1]]$wn = mk_waning(scen.dt$nat_imm_dur_days)
if (scen.dt$strategy == "campaign") {
# set parameters for this set of scenario runs
fitS$par$pop[[1]]$ev = rep(scen.dt$vax_eff, 16) #' TODO mods by age?
fitS$par$pop[[1]]$wv = mk_waning(scen.dt$vax_imm_dur_days)
doses_per_day <- rep(0, 16)
tar_ages <- scen.dt$from_age:scen.dt$to_age
#' TODO potentially make demographic sensitive?
doses_per_day[tar_ages] <- floor(scen.dt$doses_per_day/length(tar_ages))
del <- scen.dt$doses_per_day - sum(doses_per_day)
if (del) {
del_tar <- scen.dt$from_age:(scen.dt$from_age+del-1)
doses_per_day[del_tar] <- doses_per_day[del_tar] + 1
}
### NEW BIT IS HERE
fitS$par$schedule[[2]] = list(   # schedule[[2]] because schedule[[1]] is already occupied
parameter = 'v',             # impact parameter 'v' (vaccines administered per day for each age group)
pops = 0,                    # 0th population
mode = 'assign',             # assign values to v
times =     c(t_vax,           t_vax+scen.dt$strategy_str),    # do changes on vax day, vax day + 90
values = list(doses_per_day, rep(0, 16))
# however many doses a day for strategy_str days, then stop
)
}
fitS$par$schedule[[2]]
scen.dt$n_samples <- 5
# sample from posterior to generate runs
runs = cm_backend_sample_fit_test(
cm_translate_parameters(fitS$par),
fitS$post, scen.dt$n_samples, seed = scen.dt$rng_seed
)
runs
all = rbindlist(lapply(runs, function (ru) {
ru[order(t), {
ret <- lapply(
.SD[,.SD,.SDcols=-c("S","E","Ip","Is","Ia","R","t","population")],
cumsum
)
c(list(t=t), ret)
}, keyby=.(sampleId = run, age = group)
][ t %in% record_times ]
}))
long.dt <- melt.data.table(
all, id.vars = c("sampleId","age","t"), variable.name = "outcome"
)
long.dt
long.dt <- melt.data.table(
all, id.vars = c("sampleId","age","t"), variable.name = "outcome"
)
write.dt <- long.dt[,.(
scenaroId = scnid,
sampleId,
age,
simday = t,
outcome,
value_numeric = value
)]
write.dt
write.dt[t %in% anni_times]
anni_times
write.dt
write.dt[simday %in% anni_times]
log(1-.9)
log(1-.8)
log(1-.2)
-log(1-1)
-log(1-.99)
log(1-.7)
log(1)
log(1-1)
log(1-0)
log(1-0)+1
.71^2
.71^3
history()
thing <- history()
thing
?history
require(qs)
thing <- qread("fitd_sindh.qs")
thing$user_defined
?wpp2019
install.packages("stringr")
install.packages("socialmixr")
mortality
mortality <- fread("mortality.csv")
require(data.table)
mortality <- fread("mortality.csv")
mortality <- fread("data_fitting/mortality.csv")
mortality
mortality[name == "Zambia"]
mortality[name == "Zambia"][1]
mortality[name == "Zambia"][1, mx/365.25]
mortality[name == "Zambia"][1, mx/(5*365.25)]
mortality[name == "Zambia"]
mortality[name == "Zambia" & age == 5]
mortality[name == "Zambia" & age == 5]$mx/365.25
mortality[name == "Pakistan" & age == 5]$mx/365.25
mortality[name == "Pakistan" & age == 5]$qx
mortality[name == "Zambia" & age == 5]$mx/365.25
mortality[name == "Zambia"]$mx/365.25
mortality[name == "Zambia",.(mx/365.25)]
mortality[name == "Zambia",.(age, mx/365.25)]
mortality[name == "Zambia",.(age, mx, mx/365.25)]
?wpp2019
fert  <- fread("data_fitting/birthrates.csv")
fert
fert[, .(name, birth_rate/365.25)]
fert[name == "Pakistan", .(name, birth_rate/365.25)]
data(tfr)
require(wpp2019)
data(tfr)
head(tfr)
